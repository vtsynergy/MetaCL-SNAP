const char reduce_flux_moments_ocl[] ={
"\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"\n"
"#define ANGULAR_FLUX_INDEX(a,g,i,j,k,nang,ng,nx,ny) ((a)+((nang)*(g))+((nang)*(ng)*(i))+((nang)*(ng)*(nx)*(j))+((nang)*(ng)*(nx)*(ny)*(k)))\n"
"#define SCALAR_FLUX_MOMENTS_INDEX(m,g,i,j,k,cmom,ng,nx,ny) ((m)+((cmom-1)*(g))+((cmom-1)*(ng)*(i))+((cmom-1)*(ng)*(nx)*(j))+((cmom-1)*(ng)*(nx)*(ny)*(k)))\n"
"#define SCAT_COEFF_INDEX(a,l,o,nang,cmom) ((a)+((nang)*(l))+((nang)*(cmom)*o))\n"
"\n"
"#define angular_flux_in_0(a,g,i,j,k) angular_flux_in_0[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_1(a,g,i,j,k) angular_flux_in_1[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_2(a,g,i,j,k) angular_flux_in_2[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_3(a,g,i,j,k) angular_flux_in_3[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_4(a,g,i,j,k) angular_flux_in_4[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_5(a,g,i,j,k) angular_flux_in_5[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_6(a,g,i,j,k) angular_flux_in_6[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_in_7(a,g,i,j,k) angular_flux_in_7[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_0(a,g,i,j,k) angular_flux_out_0[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_1(a,g,i,j,k) angular_flux_out_1[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_2(a,g,i,j,k) angular_flux_out_2[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_3(a,g,i,j,k) angular_flux_out_3[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_4(a,g,i,j,k) angular_flux_out_4[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_5(a,g,i,j,k) angular_flux_out_5[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_6(a,g,i,j,k) angular_flux_out_6[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out_7(a,g,i,j,k) angular_flux_out_7[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"\n"
"#define scalar_flux_moments(l,g,i,j,k) scalar_flux_moments[SCALAR_FLUX_MOMENTS_INDEX((l),(g),(i),(j),(k),cmom,ng,nx,ny)]\n"
"#define scat_coeff(a,l,o) scat_coeff[SCAT_COEFF_INDEX((a),(l),(o),nang,cmom)]\n"
"\n"
"\n"
"// We want to perform a weighted sum of angles in each cell in each energy group for each moment\n"
"// One work-group per cell per energy group, and reduce within a work-group\n"
"// Work-groups must be power of two sized\n"
"kernel void reduce_flux_moments(\n"
"    const unsigned int nx,\n"
"    const unsigned int ny,\n"
"    const unsigned int nz,\n"
"    const unsigned int nang,\n"
"    const unsigned int ng,\n"
"    const unsigned int cmom,\n"
"\n"
"    global const double * restrict angular_flux_in_0,\n"
"    global const double * restrict angular_flux_in_1,\n"
"    global const double * restrict angular_flux_in_2,\n"
"    global const double * restrict angular_flux_in_3,\n"
"    global const double * restrict angular_flux_in_4,\n"
"    global const double * restrict angular_flux_in_5,\n"
"    global const double * restrict angular_flux_in_6,\n"
"    global const double * restrict angular_flux_in_7,\n"
"\n"
"    global const double * restrict angular_flux_out_0,\n"
"    global const double * restrict angular_flux_out_1,\n"
"    global const double * restrict angular_flux_out_2,\n"
"    global const double * restrict angular_flux_out_3,\n"
"    global const double * restrict angular_flux_out_4,\n"
"    global const double * restrict angular_flux_out_5,\n"
"    global const double * restrict angular_flux_out_6,\n"
"    global const double * restrict angular_flux_out_7,\n"
"\n"
"    global const double * restrict velocity_delta,\n"
"    global const double * restrict quad_weights,\n"
"    global const double * restrict scat_coeff,\n"
"\n"
"    global double * restrict scalar_flux_moments,\n"
"    local double * restrict local_scalar\n"
"    )\n"
"{\n"
"    const size_t a = get_local_id(0);\n"
"    const size_t g = get_group_id(0);\n"
"\n"
"    const size_t i = get_global_id(1) % nx;\n"
"    const size_t j = (get_global_id(1) / nx) % ny;\n"
"    const size_t k = get_global_id(1) / (nx * ny);\n"
"\n"
"    for (unsigned int l = 0; l < cmom-1; l++)\n"
"    {\n"
"        // Load into local memory\n"
"        local_scalar[a] = 0.0;\n"
"        for (unsigned int aa = a; aa < nang; aa += get_local_size(0))\n"
"        {\n"
"            const double w = quad_weights[aa];\n"
"            if (velocity_delta[g] != 0.0)\n"
"            {\n"
"                local_scalar[a] +=\n"
"                    scat_coeff(aa,l+1,0) * w * (0.5 * (angular_flux_out_0(aa,g,i,j,k) + angular_flux_in_0(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,1) * w * (0.5 * (angular_flux_out_1(aa,g,i,j,k) + angular_flux_in_1(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,2) * w * (0.5 * (angular_flux_out_2(aa,g,i,j,k) + angular_flux_in_2(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,3) * w * (0.5 * (angular_flux_out_3(aa,g,i,j,k) + angular_flux_in_3(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,4) * w * (0.5 * (angular_flux_out_4(aa,g,i,j,k) + angular_flux_in_4(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,5) * w * (0.5 * (angular_flux_out_5(aa,g,i,j,k) + angular_flux_in_5(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,6) * w * (0.5 * (angular_flux_out_6(aa,g,i,j,k) + angular_flux_in_6(aa,g,i,j,k))) +\n"
"                    scat_coeff(aa,l+1,7) * w * (0.5 * (angular_flux_out_7(aa,g,i,j,k) + angular_flux_in_7(aa,g,i,j,k)));\n"
"            }\n"
"            else\n"
"            {\n"
"                local_scalar[a] +=\n"
"                    scat_coeff(aa,l+1,0) * w * angular_flux_out_0(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,1) * w * angular_flux_out_1(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,2) * w * angular_flux_out_2(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,3) * w * angular_flux_out_3(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,4) * w * angular_flux_out_4(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,5) * w * angular_flux_out_5(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,6) * w * angular_flux_out_6(aa,g,i,j,k) +\n"
"                    scat_coeff(aa,l+1,7) * w * angular_flux_out_7(aa,g,i,j,k);\n"
"            }\n"
"        }\n"
"\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Reduce in local memory\n"
"        for (unsigned int offset = get_local_size(0) / 2; offset > 0; offset /= 2)\n"
"        {\n"
"            if (a < offset)\n"
"            {\n"
"                local_scalar[a] += local_scalar[a + offset];\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"\n"
"        // Save result\n"
"        if (a == 0)\n"
"        {\n"
"            scalar_flux_moments(l,g,i,j,k) = local_scalar[0];\n"
"        }\n"
"    } // End of moment loop\n"
"}\n"
};
