const char sweep_plane_ocl[] ={
"\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"struct cell_id\n"
"{\n"
"    unsigned int i, j, k;\n"
"};\n"
"\n"
"\n"
"#define SOURCE_INDEX(m,g,i,j,k,cmom,ng,nx,ny) ((m)+((cmom)*(g))+((cmom)*(ng)*(i))+((cmom)*(ng)*(nx)*(j))+((cmom)*(ng)*(nx)*(ny)*(k)))\n"
"#define SCAT_COEFF_INDEX(a,l,o,nang,cmom) ((a)+((nang)*(l))+((nang)*(cmom)*o))\n"
"#define FLUX_I_INDEX(a,g,j,k,nang,ng,ny) ((a)+((nang)*(g))+((nang)*(ng)*(j))+((nang)*(ng)*(ny)*(k)))\n"
"#define FLUX_J_INDEX(a,g,i,k,nang,ng,nx) ((a)+((nang)*(g))+((nang)*(ng)*(i))+((nang)*(ng)*(nx)*(k)))\n"
"#define FLUX_K_INDEX(a,g,i,j,nang,ng,nx) ((a)+((nang)*(g))+((nang)*(ng)*(i))+((nang)*(ng)*(nx)*(j)))\n"
"#define ANGULAR_FLUX_INDEX(a,g,i,j,k,nang,ng,nx,ny) ((a)+((nang)*(g))+((nang)*(ng)*(i))+((nang)*(ng)*(nx)*(j))+((nang)*(ng)*(nx)*(ny)*(k)))\n"
"#define DENOMINATOR_INDEX(a,g,i,j,k,nang,ng,nx,ny) ((a)+((nang)*(g))+((nang)*(ng)*(i))+((nang)*(ng)*(nx)*(j))+((nang)*(ng)*(nx)*(ny)*(k)))\n"
"\n"
"#define source(m,g,i,j,k) source[SOURCE_INDEX((m),(g),(i),(j),(k),cmom,ng,nx,ny)]\n"
"#define scat_coeff(a,l,o) scat_coeff[SCAT_COEFF_INDEX((a),(l),(o),nang,cmom)]\n"
"#define flux_i(a,g,j,k) flux_i[FLUX_I_INDEX((a),(g),(j),(k),nang,ng,ny)]\n"
"#define flux_j(a,g,i,k) flux_j[FLUX_J_INDEX((a),(g),(i),(k),nang,ng,nx)]\n"
"#define flux_k(a,g,i,j) flux_k[FLUX_K_INDEX((a),(g),(i),(j),nang,ng,nx)]\n"
"#define angular_flux_in(a,g,i,j,k) angular_flux_in[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define angular_flux_out(a,g,i,j,k) angular_flux_out[ANGULAR_FLUX_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"#define denominator(a,g,i,j,k) denominator[DENOMINATOR_INDEX((a),(g),(i),(j),(k),nang,ng,nx,ny)]\n"
"\n"
"\n"
"kernel void sweep_plane(\n"
"    const unsigned int nx,\n"
"    const unsigned int ny,\n"
"    const unsigned int nz,\n"
"    const unsigned int nang,\n"
"    const unsigned int ng,\n"
"    const unsigned int cmom,\n"
"    const int istep,\n"
"    const int jstep,\n"
"    const int kstep,\n"
"    const unsigned int oct,\n"
"    const unsigned int z_pos,\n"
"    global const struct cell_id * plane,\n"
"    global const double * restrict source,\n"
"    global const double * restrict scat_coeff,\n"
"    global const double * restrict dd_i,\n"
"    global const double * restrict dd_j,\n"
"    global const double * restrict dd_k,\n"
"    global const double * restrict mu,\n"
"    global const double * restrict velocity_delta,\n"
"    global const double * restrict mat_cross_section,\n"
"    global const double * restrict denominator,\n"
"    global const double * restrict angular_flux_in,\n"
"    global double * restrict flux_i,\n"
"    global double * restrict flux_j,\n"
"    global double * restrict flux_k,\n"
"    global double * restrict angular_flux_out\n"
"    )\n"
"{\n"
"    // Recover indexes for angle and group\n"
"    const size_t a = get_global_id(0) % nang;\n"
"    const size_t g = get_global_id(0) / nang;\n"
"\n"
"    // Read cell index from plane buffer\n"
"    const size_t i = (istep > 0) ? plane[get_global_id(1)].i         : nx - plane[get_global_id(1)].i         - 1;\n"
"    const size_t j = (jstep > 0) ? plane[get_global_id(1)].j         : ny - plane[get_global_id(1)].j         - 1;\n"
"    const size_t k = (kstep > 0) ? plane[get_global_id(1)].k + z_pos : nz - plane[get_global_id(1)].k - z_pos - 1;\n"
"\n"
"    //\n"
"    // Compute the angular flux (psi)\n"
"    //\n"
"\n"
"    // Begin with the first scattering moment\n"
"    double source_term = source(0,g,i,j,k);\n"
"\n"
"    // Add in the anisotropic scattering source moments\n"
"    for (unsigned int l = 1; l < cmom; l++)\n"
"    {\n"
"        source_term += scat_coeff(a,l,oct) * source(l,g,i,j,k);\n"
"    }\n"
"\n"
"    double psi =\n"
"        source_term\n"
"        + flux_i(a,g,j,k)*mu[a]*dd_i[0]\n"
"        + flux_j(a,g,i,k)*dd_j[a]\n"
"        + flux_k(a,g,i,j)*dd_k[a];\n"
"\n"
"    // Add contribution from last timestep flux if time-dependant\n"
"    if (velocity_delta[g] != 0.0)\n"
"    {\n"
"        psi += velocity_delta[g] * angular_flux_in(a,g,i,j,k);\n"
"    }\n"
"\n"
"    // \"Divide\" by denominator\n"
"    psi *= denominator(a,g,i,j,k);\n"
"\n"
"    // Compute upwind fluxes\n"
"    double tmp_flux_i = 2.0 * psi - flux_i(a,g,j,k);\n"
"    double tmp_flux_j = 2.0 * psi - flux_j(a,g,i,k);\n"
"    double tmp_flux_k = 2.0 * psi - flux_k(a,g,i,j);\n"
"\n"
"    // Time difference the final flux value\n"
"    if (velocity_delta[g] != 0.0)\n"
"    {\n"
"        psi = 2.0 * psi - angular_flux_in(a,g,i,j,k);\n"
"    }\n"
"\n"
"    // Fixup\n"
"    double zeros[4];\n"
"    int num_ok = 4;\n"
"    for (int fix = 0; fix < 4; fix++)\n"
"    {\n"
"        zeros[0] = (tmp_flux_i < 0.0) ? 0.0 : 1.0;\n"
"        zeros[1] = (tmp_flux_j < 0.0) ? 0.0 : 1.0;\n"
"        zeros[2] = (tmp_flux_k < 0.0) ? 0.0 : 1.0;\n"
"        zeros[3] = (psi < 0.0)        ? 0.0 : 1.0;\n"
"\n"
"        if (num_ok == zeros[0] + zeros[1] + zeros[2] + zeros[3])\n"
"            continue;\n"
"\n"
"        num_ok = zeros[0] + zeros[1] + zeros[2] + zeros[3];\n"
"\n"
"        // Recalculate psi\n"
"        psi =\n"
"            flux_i(a,g,j,k)*mu[a]*dd_i[0]*(1.0 + zeros[0]) +\n"
"            flux_j(a,g,i,k)*dd_j[a]*(1.0 + zeros[1]) +\n"
"            flux_k(a,g,i,j)*dd_k[a]*(1.0 + zeros[2]);\n"
"\n"
"        if (velocity_delta[g] != 0.0)\n"
"        {\n"
"            psi += velocity_delta[g] * angular_flux_in(a,g,i,j,k) * (1.0 + zeros[3]);\n"
"        }\n"
"\n"
"        psi = 0.5 * psi + source_term;\n"
"\n"
"        double new_denominator =\n"
"            mat_cross_section[g] +\n"
"            mu[a] * dd_i[0] * zeros[0] +\n"
"            dd_j[a] * zeros[1] +\n"
"            dd_k[a] * zeros[2] +\n"
"            velocity_delta[g] * zeros[3];\n"
"        if (new_denominator > 1.0E-12)\n"
"        {\n"
"            psi /= new_denominator;\n"
"        }\n"
"        else\n"
"        {\n"
"            psi = 0.0;\n"
"        }\n"
"\n"
"        tmp_flux_i = 2.0 * psi - flux_i(a,g,j,k);\n"
"        tmp_flux_j = 2.0 * psi - flux_j(a,g,i,k);\n"
"        tmp_flux_k = 2.0 * psi - flux_k(a,g,i,j);\n"
"\n"
"        if (velocity_delta[g] != 0.0)\n"
"        {\n"
"            psi = 2.0 * psi - angular_flux_in(a,g,i,j,k);\n"
"        }\n"
"\n"
"    }\n"
"\n"
"    // Write values to global memory\n"
"    flux_i(a,g,j,k) = tmp_flux_i * zeros[0];\n"
"    flux_j(a,g,i,k) = tmp_flux_j * zeros[1];\n"
"    flux_k(a,g,i,j) = tmp_flux_k * zeros[2];\n"
"    angular_flux_out(a,g,i,j,k) = psi * zeros[3];\n"
"}\n"
};
